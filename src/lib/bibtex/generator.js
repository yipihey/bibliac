/**
 * ADS Reader Core - BibTeX Generator
 *
 * Functions for generating BibTeX entries and cite commands.
 */

/**
 * Generate BibTeX key from paper info
 * @param {Partial<import('../types.js').Paper>} paper
 * @returns {string}
 */
export function generateBibtexKey(paper) {
  // If bibcode exists, use a cleaned version
  if (paper.bibcode) {
    return paper.bibcode.replace(/[^a-zA-Z0-9]/g, '');
  }

  // Otherwise generate from author + year
  let key = '';

  if (paper.authors && paper.authors.length > 0) {
    const firstAuthor = paper.authors[0];
    const lastName = firstAuthor.split(',')[0].trim().replace(/[^a-zA-Z]/g, '');
    key = lastName;
  } else {
    key = 'Unknown';
  }

  if (paper.year) {
    key += paper.year;
  }

  // Add title word if needed
  if (paper.title) {
    const titleWord = paper.title.split(/\s+/).find(w => w.length > 3);
    if (titleWord) {
      key += titleWord.replace(/[^a-zA-Z]/g, '');
    }
  }

  return key;
}

/**
 * Escape special LaTeX characters
 * @param {string} str
 * @returns {string}
 */
export function escapeLatex(str) {
  if (!str) return '';

  return str
    .replace(/\\/g, '\\textbackslash{}')
    .replace(/&/g, '\\&')
    .replace(/%/g, '\\%')
    .replace(/\$/g, '\\$')
    .replace(/#/g, '\\#')
    .replace(/_/g, '\\_')
    .replace(/{/g, '\\{')
    .replace(/}/g, '\\}')
    .replace(/~/g, '\\textasciitilde{}')
    .replace(/\^/g, '\\textasciicircum{}');
}

/**
 * Generate BibTeX entry from paper
 * @param {Partial<import('../types.js').Paper>} paper
 * @returns {string}
 */
export function paperToBibtex(paper) {
  // If paper already has bibtex, return it
  if (paper.bibtex) {
    return paper.bibtex;
  }

  const key = generateBibtexKey(paper);
  const type = paper.arxiv_id && !paper.journal ? 'misc' : 'article';

  const lines = [`@${type}{${key},`];

  if (paper.title) {
    lines.push(`  title = {${escapeLatex(paper.title)}},`);
  }

  if (paper.authors && paper.authors.length > 0) {
    const authorStr = paper.authors.join(' and ');
    lines.push(`  author = {${escapeLatex(authorStr)}},`);
  }

  if (paper.year) {
    lines.push(`  year = {${paper.year}},`);
  }

  if (paper.journal) {
    lines.push(`  journal = {${escapeLatex(paper.journal)}},`);
  }

  if (paper.doi) {
    lines.push(`  doi = {${paper.doi}},`);
  }

  if (paper.arxiv_id) {
    lines.push(`  eprint = {${paper.arxiv_id}},`);
    lines.push(`  archivePrefix = {arXiv},`);
  }

  if (paper.bibcode) {
    lines.push(`  adsurl = {https://ui.adsabs.harvard.edu/abs/${paper.bibcode}},`);
  }

  if (paper.abstract) {
    lines.push(`  abstract = {${escapeLatex(paper.abstract)}},`);
  }

  // Remove trailing comma from last entry
  const lastLine = lines[lines.length - 1];
  lines[lines.length - 1] = lastLine.replace(/,$/, '');

  lines.push('}');

  return lines.join('\n');
}

/**
 * Get \cite command for clipboard
 * @param {Partial<import('../types.js').Paper>} paper
 * @param {'cite'|'citep'|'citet'|'citeauthor'} [style='cite']
 * @returns {string}
 */
export function getCiteCommand(paper, style = 'cite') {
  const key = generateBibtexKey(paper);

  switch (style) {
    case 'citep':
      return `\\citep{${key}}`;
    case 'citet':
      return `\\citet{${key}}`;
    case 'citeauthor':
      return `\\citeauthor{${key}}`;
    default:
      return `\\cite{${key}}`;
  }
}

/**
 * Get \cite command for multiple papers
 * @param {Partial<import('../types.js').Paper>[]} papers
 * @param {'cite'|'citep'|'citet'|'citeauthor'} [style='cite']
 * @returns {string}
 */
export function getMultiCiteCommand(papers, style = 'cite') {
  const keys = papers.map(p => generateBibtexKey(p)).join(', ');

  switch (style) {
    case 'citep':
      return `\\citep{${keys}}`;
    case 'citet':
      return `\\citet{${keys}}`;
    case 'citeauthor':
      return `\\citeauthor{${keys}}`;
    default:
      return `\\cite{${keys}}`;
  }
}

/**
 * Generate BibTeX file content from papers
 * @param {Partial<import('../types.js').Paper>[]} papers
 * @param {Object} [options]
 * @param {string} [options.header] - Optional header comment
 * @returns {string}
 */
export function generateBibtexFile(papers, options = {}) {
  const header = options.header || `% BibTeX file generated by ADS Reader
% Generated: ${new Date().toISOString()}
% Entries: ${papers.length}

`;

  const entries = papers
    .map(paper => paperToBibtex(paper))
    .join('\n\n');

  return header + entries + '\n';
}
